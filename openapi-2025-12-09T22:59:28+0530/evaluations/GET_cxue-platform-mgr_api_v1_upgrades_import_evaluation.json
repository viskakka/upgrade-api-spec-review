[
  {
    "rule": {
      "rule_id": "SEMANTIC.NAMING.FIELD.03-02",
      "domain": "REST;GraphQL;gRPC;Devices",
      "priority": "P1",
      "priority_reasoning": "The rule uses prescriptive language ('Use the {qualifier}At pattern') with clear structural requirements for timestamp fields. This is a foundational naming convention ensuring consistency for date-time fields across APIs.",
      "category": "Temporal Field Naming - Timestamp Fields",
      "file_reference": "products/semantic/SEMANTIC.NAMING.FIELD.03.md",
      "summary": "APIs must use the {qualifier}At pattern for fields that include both date and time information. This applies to action timestamps (createdAt, updatedAt), event timestamps (signedAt, approvedAt), observation timestamps (observedAt, measuredAt), and time-bounded ranges (warrantyStartAt, warrantyEndAt).",
      "original_content": "### Timestamp Fields (Date + Time)\n\nUse the `{qualifier}At` pattern for fields that include both date and time information.\n\n| Pattern | Usage | Examples |\n|---------|-------|----------|\n| `{action}At` | Timestamp fields for completed actions (past events) | `createdAt`, `updatedAt`, `publishedAt`, `expiredAt` |\n| `{event}At` | Timestamps for events that have occurred | `signedAt`, `approvedAt`, `processedAt`, `completedAt` |\n| `{observation}At` | Timestamps for when state or data was observed | `observedAt`, `measuredAt`, `sampledAt`, `detectedAt` |\n| `last{Action}At` | Most recent occurrence of an action | `lastSignedAt`, `lastScannedAt`, `lastAccessedAt`, `lastLoginTime` |\n| `next{Action}At` | Next scheduled occurrence of an action | `nextBackupAt`, `nextScanAt`, `nextRenewalAt` |\n| `{qualifier}StartAt`/`{qualifier}EndAt` | Timestamp range boundaries | `warrantyStartAt`, `warrantyEndAt`, `maintenanceStartAt`, `maintenanceEndAt` |",
      "has_examples": true,
      "confidence": 0.95,
      "confidence_reasoning": "The rule is explicitly stated with clear pattern specifications and comprehensive categorized examples in a structured table. Requirements are unambiguous and directly actionable.",
      "classification": "InSpec",
      "classification_reasoning": "This rule governs field naming in API specifications and can be verified by analyzing OpenAPI, GraphQL schema, or Protocol Buffer definitions to check if timestamp fields follow the {qualifier}At pattern.",
      "requires_llm_evaluation": false,
      "llm_evaluation_reasoning": "üîß Static analysis can verify this rule using regex pattern matching against field names in specifications. Check for fields representing timestamps using naming pattern analysis: fields should match `.*At$` pattern with appropriate qualifiers or `last.*At$`/`next.*At$` patterns.",
      "is_reviewed": false,
      "is_updated": false,
      "url": "https://developer.cisco.com/api-guidelines/semantic-naming-field-03/#timestamp-fields-date--time"
    },
    "status": "FAIL",
    "priority": "P1",
    "priority_reasoning": "MUST - Timestamp field naming consistency is foundational to API quality and developer experience.",
    "recommendation": {
      "location": "paths./cxue-platform-mgr/api/v1/upgrades/import.get.responses.200.content.application/json.schema.properties - multiple timestamp fields (createdAt, updatedAt, startTime, endTime)",
      "reasoning": "The API specification contains timestamp fields with inconsistent naming patterns. The fields 'startTime' and 'endTime' appear in the StageInfo schema (used in completedStages and currentStage arrays) and violate the {qualifier}At naming convention. According to SEMANTIC.NAMING.FIELD.03-02, timestamp fields representing when stages started or ended should follow the pattern 'startedAt' and 'completedAt' or similar {qualifier}At format. Additionally, 'createdAt' and 'updatedAt' in the BundleStatus schema correctly follow the pattern, but 'startTime' and 'endTime' should be 'startedAt' and 'endedAt' for consistency. The field 'elapsedTime' is a duration (measured in seconds) and should be 'elapsedSeconds' per SEMANTIC.NAMING.FIELD.03-05 for explicit unit specification.",
      "is_breaking_change": true,
      "is_breaking_change_reasoning": "üí• Renaming timestamp fields from 'startTime'/'endTime' to 'startedAt'/'endedAt' is a breaking change as existing API consumers depend on the current field names in their code and will experience parsing failures or null reference errors when fields are renamed. Additionally, renaming 'elapsedTime' to 'elapsedSeconds' breaks existing client code. Clients must update field references in serialization/deserialization code.",
      "current_spec": "\"startTime\": {\n  \"anyOf\": [\n    {\"type\": \"string\"},\n    {\"type\": \"null\"}\n  ],\n  \"format\": \"date-time\",\n  \"title\": \"Starttime\",\n  \"description\": \"ISO timestamp when stage started\"\n},\n\"endTime\": {\n  \"anyOf\": [\n    {\"type\": \"string\"},\n    {\"type\": \"null\"}\n  ],\n  \"format\": \"date-time\",\n  \"title\": \"Endtime\",\n  \"description\": \"ISO timestamp when stage ended\"\n},\n\"elapsedTime\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"Elapsedtime\",\n  \"description\": \"Elapsed time in seconds\"\n}",
      "recommended_spec": "\"startedAt\": {\n  \"anyOf\": [\n    {\"type\": \"string\"},\n    {\"type\": \"null\"}\n  ],\n  \"format\": \"date-time\",\n  \"title\": \"StartedAt\",\n  \"description\": \"ISO timestamp when stage started\"\n},\n\"completedAt\": {\n  \"anyOf\": [\n    {\"type\": \"string\"},\n    {\"type\": \"null\"}\n  ],\n  \"format\": \"date-time\",\n  \"title\": \"CompletedAt\",\n  \"description\": \"ISO timestamp when stage ended\"\n},\n\"elapsedSeconds\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"ElapsedSeconds\",\n  \"description\": \"Elapsed time in seconds\",\n  \"x-unit\": \"s\"\n}",
      "markdown": "## üü† P1 Timestamp Field Naming Inconsistency\n\n### Overview\n| | |\n|---|---|\n| **Priority Reasoning** | MUST - Timestamp field naming consistency is foundational to API quality and developer experience. |\n| **Issue** | Timestamp fields use inconsistent naming patterns (startTime/endTime vs. {qualifier}At convention) |\n| **Rule** | SEMANTIC.NAMING.FIELD.03-02 - https://developer.cisco.com/api-guidelines/semantic-naming-field-03/#timestamp-fields-date--time |\n| **Breaking Change** | true |\n| **Location** | StageInfo schema properties in components.schemas and paths./cxue-platform-mgr/api/v1/upgrades/import.get.responses.200 |\n\n### Analysis\n\n#### Issue Reasoning\nThe StageInfo schema (used in completedStages and currentStage arrays) contains timestamp fields 'startTime' and 'endTime' that violate the {qualifier}At naming convention specified in SEMANTIC.NAMING.FIELD.03-02. Per the rule, timestamp fields representing when events occurred (stage started/completed) should follow the {qualifier}At pattern (e.g., startedAt, completedAt). The rule explicitly states this pattern applies to \"action timestamps\" and similar operational timestamps. Additionally, the 'elapsedTime' field lacks explicit unit specification; per SEMANTIC.NAMING.FIELD.03-05, numeric durations should include units (elapsedSeconds).\n\n#### Issue Impact\nDevelopers consuming this API will encounter inconsistent timestamp naming conventions within a single API response object. The BundleStatus schema correctly uses 'createdAt' and 'updatedAt', but the nested StageInfo objects use 'startTime' and 'endTime', creating a confusing and non-uniform pattern. This reduces API usability and violates Cisco API naming standards.\n\n#### Breaking Change Reasoning\nüí• Renaming fields from 'startTime'/'endTime' to 'startedAt'/'endedAt' is a breaking change. Existing API clients have hardcoded field references in JSON deserialization logic (e.g., payload.startTime, payload.endTime). When fields are renamed, clients attempting to access the old field names will receive undefined/null values or throw exceptions. Client code must be updated to reference the new field names, requiring version bumps or dual-field support during deprecation periods.\n\n### Implementation\n\n#### Current Implementation\n```json\n\"startTime\": {\n  \"anyOf\": [\n    {\"type\": \"string\"},\n    {\"type\": \"null\"}\n  ],\n  \"format\": \"date-time\",\n  \"title\": \"Starttime\",\n  \"description\": \"ISO timestamp when stage started\"\n},\n\"endTime\": {\n  \"anyOf\": [\n    {\"type\": \"string\"},\n    {\"type\": \"null\"}\n  ],\n  \"format\": \"date-time\",\n  \"title\": \"Endtime\",\n  \"description\": \"ISO timestamp when stage ended\"\n},\n\"elapsedTime\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"Elapsedtime\",\n  \"description\": \"Elapsed time in seconds\"\n}\n```\n\n#### Recommended Implementation\n```json\n\"startedAt\": {\n  \"anyOf\": [\n    {\"type\": \"string\"},\n    {\"type\": \"null\"}\n  ],\n  \"format\": \"date-time\",\n  \"title\": \"StartedAt\",\n  \"description\": \"ISO timestamp when stage started\"\n},\n\"completedAt\": {\n  \"anyOf\": [\n    {\"type\": \"string\"},\n    {\"type\": \"null\"}\n  ],\n  \"format\": \"date-time\",\n  \"title\": \"CompletedAt\",\n  \"description\": \"ISO timestamp when stage ended\"\n},\n\"elapsedSeconds\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"ElapsedSeconds\",\n  \"description\": \"Elapsed time in seconds\",\n  \"x-unit\": \"s\"\n}\n```"
    }
  },
  {
    "rule": {
      "rule_id": "SEMANTIC.NAMING.FIELD.01-10",
      "domain": "REST;GraphQL;gRPC",
      "priority": "P0",
      "priority_reasoning": "Uses explicit 'MUST' keyword. Field descriptions are critical for API usability and reduce ambiguity in API consumption and implementation.",
      "category": "Naming - Field Descriptions",
      "file_reference": "products/semantic/SEMANTIC.NAMING.FIELD.01.md",
      "summary": "All fields must include clear, concise descriptions in API specifications (OpenAPI, GraphQL schema, Protocol Buffer definitions) that explain the field's purpose, expected values, and usage context. Descriptions should resolve ambiguity and provide complete understanding of the field.",
      "original_content": "## Field Description Guidelines\n\nAll fields MUST include clear, concise descriptions in API specifications (OpenAPI, GraphQL schema, Protocol Buffer definitions) that explain the field's purpose, expected values, and usage context.\n\n**Good descriptions resolve ambiguity**:\n\n- ‚úÖ `\"roles\": \"Available roles for this user. User must select one role during login to determine session permissions\"`\n- ‚úÖ `\"deviceStatus\": \"Current operational state of the device. Updated every 5 minutes\"`\n- ‚úÖ `\"parentId\": \"ID of the immediate parent resource. Null for top-level resources\"`\n\n**Poor descriptions create ambiguity**:\n\n- ‚ùå `\"roles\": \"User roles\"` (Does user get all permissions? Must they select a role?)\n- ‚ùå `\"deviceStatus\": \"Device status\"` (Real-time or cached? How often updated?)",
      "has_examples": true,
      "confidence": 0.95,
      "confidence_reasoning": "Explicit MUST requirement with three good examples and two poor examples showing the difference between descriptions that resolve vs create ambiguity. The distinction is clear.",
      "classification": "InSpec",
      "classification_reasoning": "Field descriptions can be directly examined in API specifications to verify their presence and quality.",
      "requires_llm_evaluation": true,
      "llm_evaluation_reasoning": "ü§ñ While presence of descriptions can be detected statically, determining whether a description is 'clear and concise' and 'resolves ambiguity' requires semantic analysis and understanding of what constitutes sufficient explanation for developers.",
      "is_reviewed": false,
      "is_updated": false,
      "url": "https://developer.cisco.com/api-guidelines/semantic-naming-field-01/#field-description-guidelines"
    },
    "status": "PARTIAL",
    "priority": "P0",
    "priority_reasoning": "MUST - Field descriptions are critical for API usability and reduce ambiguity in implementation.",
    "recommendation": {
      "location": "components.schemas.BundleStatus.properties and components.schemas.StageInfo.properties - multiple fields",
      "reasoning": "Multiple fields in the BundleStatus and StageInfo schemas have minimal or unclear descriptions. For example: (1) 'bundleId' has description 'Unique identifier for the bundle' which is self-evident; (2) 'fileName' has 'Name of the upgrade bundle file' which lacks context about format/encoding; (3) 'fileSource' description states 'Source of the file (remote_host:path or local upload)' but doesn't explain what 'remote_host:path' format means; (4) 'status' field describing 'Current bundle status' is vague about which status values are valid beyond the enum; (5) 'failed' field in StageInfo states 'Whether the stage failed' but lacks information about when this field is set (at stage completion? on error?). Per SEMANTIC.NAMING.FIELD.01-10, descriptions must be 'clear and concise' and 'resolve ambiguity' - current descriptions are too brief and lack actionable context.",
      "is_breaking_change": false,
      "is_breaking_change_reasoning": "üõ°Ô∏è Adding or improving field descriptions in the OpenAPI specification is non-breaking. It does not change field names, types, or values - it only enhances documentation metadata. Existing API clients continue to function identically; this change only improves developer understanding.",
      "current_spec": "\"bundleId\": {\n  \"type\": \"string\",\n  \"format\": \"uuid\",\n  \"title\": \"Bundleid\",\n  \"description\": \"Unique identifier for the bundle\"\n},\n\"fileName\": {\n  \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n  \"title\": \"Filename\",\n  \"description\": \"Name of the upgrade bundle file\"\n},\n\"fileSource\": {\n  \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n  \"title\": \"Filesource\",\n  \"description\": \"Source of the file (remote_host:path or local upload)\"\n},\n\"status\": {\n  \"anyOf\": [{\n    \"type\": \"string\",\n    \"enum\": [\"inProgress\", \"completed\", \"failed\"],\n    \"title\": \"StageStatus\",\n    \"description\": \"Enum for bundle processing stage statuses.\"\n  }, {\"type\": \"null\"}],\n  \"description\": \"Current bundle status\"\n},\n\"failed\": {\n  \"type\": \"boolean\",\n  \"title\": \"Failed\",\n  \"description\": \"Whether the stage failed\",\n  \"default\": false\n}",
      "recommended_spec": "\"bundleId\": {\n  \"type\": \"string\",\n  \"format\": \"uuid\",\n  \"title\": \"Bundleid\",\n  \"description\": \"Unique identifier (UUID v4) for the upgrade bundle. This identifier persists across the entire bundle lifecycle and is used to correlate import progress with backend processing.\"\n},\n\"fileName\": {\n  \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n  \"title\": \"Filename\",\n  \"description\": \"Name of the upgrade bundle file as provided during upload. May include file extension (e.g., bundle-v2.0.zstd). Null if bundle import has not yet retrieved file metadata.\"\n},\n\"fileSource\": {\n  \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n  \"title\": \"Filesource\",\n  \"description\": \"Origin of the upgrade bundle file. Format: 'remote_host:path' for remote sources (e.g., '192.168.1.1:/upgrades/bundle.zstd') or 'local upload' for files uploaded directly via multipart form data. Null if source not yet determined.\"\n},\n\"status\": {\n  \"anyOf\": [{\n    \"type\": \"string\",\n    \"enum\": [\"inProgress\", \"completed\", \"failed\"],\n    \"title\": \"StageStatus\",\n    \"description\": \"Overall bundle processing status: 'inProgress' indicates active import, 'completed' indicates all stages finished successfully, 'failed' indicates an error occurred during processing.\"\n  }, {\"type\": \"null\"}],\n  \"description\": \"Current bundle import status. Transitions from inProgress to either completed or failed.\"\n},\n\"failed\": {\n  \"type\": \"boolean\",\n  \"title\": \"Failed\",\n  \"description\": \"Indicates whether the stage encountered an error. Set to true when a stage completes with status='failed', false for successful or in-progress stages. Used for quick error detection without parsing status enum.\",\n  \"default\": false\n}",
      "markdown": "## üî¥ P0 Insufficient Field Descriptions\n\n### Overview\n| | |\n|---|---|\n| **Priority Reasoning** | MUST - Field descriptions are critical for API usability and reduce ambiguity in implementation. |\n| **Issue** | Multiple fields have minimal or unclear descriptions that do not sufficiently explain purpose, values, or usage context |\n| **Rule** | SEMANTIC.NAMING.FIELD.01-10 - https://developer.cisco.com/api-guidelines/semantic-naming-field-01/#field-description-guidelines |\n| **Breaking Change** | false |\n| **Location** | components.schemas.BundleStatus.properties and components.schemas.StageInfo.properties |\n\n### Analysis\n\n#### Issue Reasoning\nMultiple fields in the API specification have descriptions that are too brief or vague per SEMANTIC.NAMING.FIELD.01-10 requirements. Examples: (1) bundleId description 'Unique identifier for the bundle' is self-evident and lacks context about its format/lifecycle persistence; (2) fileSource description 'Source of the file (remote_host:path or local upload)' mentions the format but doesn't explain what remote_host:path specifically means or how it differs from local upload; (3) status field description 'Current bundle status' doesn't enumerate the valid status values beyond the enum constraint; (4) failed field description 'Whether the stage failed' doesn't clarify when this flag is set relative to the status field or the stage lifecycle. Per the rule, descriptions must be 'clear and concise' and must 'resolve ambiguity' - current descriptions fail this test.\n\n#### Issue Impact\nDevelopers using this API will struggle to understand field semantics and may misinterpret data values. For example, a developer might not understand that fileSource format is 'ip:path' or might confuse the boolean 'failed' field with the 'status' field's failure indication. This creates integration bugs and increases support burden.\n\n#### Breaking Change Reasoning\nüõ°Ô∏è Adding or enhancing field descriptions in the OpenAPI specification is non-breaking. Field descriptions are documentation metadata only - they do not affect the JSON serialization, HTTP behavior, or data contract. Existing API clients continue to function identically. This change only improves developer understanding without modifying any structural or behavioral aspects of the API.\n\n### Implementation\n\n#### Current Implementation\n```json\n\"bundleId\": {\n  \"type\": \"string\",\n  \"format\": \"uuid\",\n  \"title\": \"Bundleid\",\n  \"description\": \"Unique identifier for the bundle\"\n},\n\"fileName\": {\n  \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n  \"title\": \"Filename\",\n  \"description\": \"Name of the upgrade bundle file\"\n},\n\"fileSource\": {\n  \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n  \"title\": \"Filesource\",\n  \"description\": \"Source of the file (remote_host:path or local upload)\"\n},\n\"status\": {\n  \"anyOf\": [{\n    \"type\": \"string\",\n    \"enum\": [\"inProgress\", \"completed\", \"failed\"],\n    \"title\": \"StageStatus\",\n    \"description\": \"Enum for bundle processing stage statuses.\"\n  }, {\"type\": \"null\"}],\n  \"description\": \"Current bundle status\"\n},\n\"failed\": {\n  \"type\": \"boolean\",\n  \"title\": \"Failed\",\n  \"description\": \"Whether the stage failed\",\n  \"default\": false\n}\n```\n\n#### Recommended Implementation\n```json\n\"bundleId\": {\n  \"type\": \"string\",\n  \"format\": \"uuid\",\n  \"title\": \"Bundleid\",\n  \"description\": \"Unique identifier (UUID v4) for the upgrade bundle. This identifier persists across the entire bundle lifecycle and is used to correlate import progress with backend processing.\"\n},\n\"fileName\": {\n  \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n  \"title\": \"Filename\",\n  \"description\": \"Name of the upgrade bundle file as provided during upload. May include file extension (e.g., bundle-v2.0.zstd). Null if bundle import has not yet retrieved file metadata.\"\n},\n\"fileSource\": {\n  \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}],\n  \"title\": \"Filesource\",\n  \"description\": \"Origin of the upgrade bundle file. Format: 'remote_host:path' for remote sources (e.g., '192.168.1.1:/upgrades/bundle.zstd') or 'local upload' for files uploaded directly via multipart form data. Null if source not yet determined.\"\n},\n\"status\": {\n  \"anyOf\": [{\n    \"type\": \"string\",\n    \"enum\": [\"inProgress\", \"completed\", \"failed\"],\n    \"title\": \"StageStatus\",\n    \"description\": \"Overall bundle processing status: 'inProgress' indicates active import, 'completed' indicates all stages finished successfully, 'failed' indicates an error occurred during processing.\"\n  }, {\"type\": \"null\"}],\n  \"description\": \"Current bundle import status. Transitions from inProgress to either completed or failed.\"\n},\n\"failed\": {\n  \"type\": \"boolean\",\n  \"title\": \"Failed\",\n  \"description\": \"Indicates whether the stage encountered an error. Set to true when a stage completes with status='failed', false for successful or in-progress stages. Used for quick error detection without parsing status enum.\",\n  \"default\": false\n}\n```"
    }
  },
  {
    "rule": {
      "rule_id": "SEMANTIC.NAMING.FIELD.04-12",
      "domain": "REST;GraphQL;gRPC",
      "priority": "P1",
      "priority_reasoning": "The document states 'All quantity fields MUST include unit information through schema-level unit annotations' using explicit MUST language, establishing a mandatory requirement for all quantity fields.",
      "category": "Unit Annotation - Mandatory Inclusion",
      "file_reference": "products/semantic/SEMANTIC.NAMING.FIELD.04.md",
      "summary": "All quantity fields in API specifications must include explicit unit information through schema-level unit annotations. Unit information must be provided in the schema layer (via x-unit, @unit directives, or protobuf options) rather than relying on documentation or implicit understanding.",
      "original_content": "## Unit Annotation Requirements\n\nAll quantity fields MUST include unit information through schema-level unit annotations.",
      "has_examples": true,
      "confidence": 0.99,
      "confidence_reasoning": "The requirement uses explicit MUST language with clear scope ('all quantity fields'). Unambiguous mandate with no conditional qualifiers. Very high confidence due to prescriptive force.",
      "classification": "InSpec",
      "classification_reasoning": "This rule is directly verifiable by analyzing the API specification to confirm that all numeric quantity fields have schema-level unit annotations present (x-unit, @unit, or field options).",
      "requires_llm_evaluation": false,
      "llm_evaluation_reasoning": "üîß Static analysis can verify this by: (1) Identifying all numeric quantity fields in the schema, (2) Checking for presence of unit annotation metadata (x-unit for OpenAPI, @unit for GraphQL, field options for protobuf), (3) Ensuring the annotation is not empty or null.",
      "is_reviewed": false,
      "is_updated": false,
      "url": "https://developer.cisco.com/api-guidelines/semantic-naming-field-04/#unit-annotation-requirements"
    },
    "status": "PARTIAL",
    "priority": "P1",
    "priority_reasoning": "MUST - Unit annotations on quantity fields are mandatory per explicit requirement language.",
    "recommendation": {
      "location": "components.schemas.StageInfo.properties.elapsedTime and components.schemas.BundleStatus.properties.fileSize",
      "reasoning": "The specification includes numeric quantity fields (elapsedTime in seconds, fileSize in bytes) that lack schema-level unit annotations. Per SEMANTIC.NAMING.FIELD.04-12, all quantity fields MUST include explicit unit information through schema-level unit annotations (x-unit for OpenAPI, @unit directives, or protobuf options). Current specification shows: (1) 'elapsedTime' with type integer and description 'Elapsed time in seconds' but no x-unit annotation; (2) 'fileSize' with type integer and description 'Size of the file in bytes' but no x-unit annotation. The units are documented in descriptions but not in schema-level annotations per the rule requirement.",
      "is_breaking_change": false,
      "is_breaking_change_reasoning": "üõ°Ô∏è Adding schema-level unit annotations (x-unit metadata) is non-breaking. The x-unit field is OpenAPI extension metadata that does not affect JSON serialization, field types, or API behavior. Existing clients continue to function identically - this change only adds metadata for tooling and documentation generation without modifying the actual data contract.",
      "current_spec": "\"elapsedTime\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"Elapsedtime\",\n  \"description\": \"Elapsed time in seconds\"\n},\n\"fileSize\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"Filesize\",\n  \"description\": \"Size of the file in bytes\"\n}",
      "recommended_spec": "\"elapsedTime\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"Elapsedtime\",\n  \"description\": \"Elapsed time in seconds\",\n  \"x-unit\": \"s\"\n},\n\"fileSize\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"Filesize\",\n  \"description\": \"Size of the file in bytes\",\n  \"x-unit\": \"byte\"\n}",
      "markdown": "## üü† P1 Missing Unit Annotations on Quantity Fields\n\n### Overview\n| | |\n|---|---|\n| **Priority Reasoning** | MUST - Unit annotations on quantity fields are mandatory per explicit requirement language. |\n| **Issue** | Numeric quantity fields (elapsedTime, fileSize) lack schema-level unit annotations |\n| **Rule** | SEMANTIC.NAMING.FIELD.04-12 - https://developer.cisco.com/api-guidelines/semantic-naming-field-04/#unit-annotation-requirements |\n| **Breaking Change** | false |\n| **Location** | components.schemas.StageInfo.properties.elapsedTime and components.schemas.BundleStatus.properties.fileSize |\n\n### Analysis\n\n#### Issue Reasoning\nThe API specification includes numeric quantity fields that lack mandatory schema-level unit annotations as required by SEMANTIC.NAMING.FIELD.04-12. The rule states: 'All quantity fields in API specifications must include explicit unit information through schema-level unit annotations.' Current fields: (1) 'elapsedTime' is documented as 'Elapsed time in seconds' but contains no x-unit annotation; (2) 'fileSize' is documented as 'Size of the file in bytes' but contains no x-unit annotation. Units are described in the description text but not in the schema layer where tooling and code generators expect them per the rule requirement.\n\n#### Issue Impact\nWithout schema-level unit annotations, API tooling cannot reliably parse quantity semantics. SDK generators cannot automatically add unit conversion helpers, API documentation generators cannot display units consistently, and clients must rely on description text rather than structured data. This violates the principle of explicit schema semantics and reduces API quality for automation and tooling.\n\n#### Breaking Change Reasoning\nüõ°Ô∏è Adding schema-level unit annotations (x-unit OpenAPI extension metadata) is non-breaking. The x-unit field is purely metadata that extends the OpenAPI schema without affecting JSON structure, field types, or serialization. Existing API clients parsing responses continue to work identically - they simply ignore the x-unit extension if not understood. This is a documentation/metadata enhancement only.\n\n### Implementation\n\n#### Current Implementation\n```json\n\"elapsedTime\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"Elapsedtime\",\n  \"description\": \"Elapsed time in seconds\"\n},\n\"fileSize\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"Filesize\",\n  \"description\": \"Size of the file in bytes\"\n}\n```\n\n#### Recommended Implementation\n```json\n\"elapsedTime\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"Elapsedtime\",\n  \"description\": \"Elapsed time in seconds\",\n  \"x-unit\": \"s\"\n},\n\"fileSize\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"Filesize\",\n  \"description\": \"Size of the file in bytes\",\n  \"x-unit\": \"byte\"\n}\n```"
    }
  },
  {
    "rule": {
      "rule_id": "SEMANTIC.NAMING.FIELD.03-05",
      "domain": "REST;GraphQL;gRPC;Devices",
      "priority": "P1",
      "priority_reasoning": "The rule uses prescriptive language ('include the unit explicitly') for numerical duration values. This is a key convention for clarity and is a foundational naming pattern for duration fields with explicit units.",
      "category": "Temporal Field Naming - Duration Fields",
      "file_reference": "products/semantic/SEMANTIC.NAMING.FIELD.03.md",
      "summary": "APIs using numerical values for durations must include the unit explicitly in the field name using the {qualifier}{Unit} pattern. This applies to simple durations (timeoutSeconds, retentionHours), maximum durations (maxTimeoutSeconds, maxSessionDurationHours), and minimum durations (minTimeoutSeconds, minSessionDurationMinutes).",
      "original_content": "When using numerical values, include the unit explicitly in the field name using the `{qualifier}{Unit}` pattern:\n\n| Pattern | Usage | Examples |\n|---------|-------|----------|\n| `{qualifier}{Units}` | Duration | `timeoutSeconds`, `retentionHours`, `backupRetentionDays` |\n| `max{Qualifier}{Unit}` | Maximum duration with unit | `maxTimeoutSeconds`, `maxSessionDurationHours`, `maxRetentionDays` |\n| `min{Qualifier}{Unit}` | Minimum duration with unit | `minTimeoutSeconds`, `minSessionDurationMinutes`, `minRetentionDays` |",
      "has_examples": true,
      "confidence": 0.95,
      "confidence_reasoning": "The rule is explicitly stated with clear pattern definitions and comprehensive examples in a structured table. Requirements are unambiguous and directly actionable.",
      "classification": "InSpec",
      "classification_reasoning": "This rule governs field naming in API specifications and can be verified by analyzing OpenAPI, GraphQL schema, or Protocol Buffer definitions to check if numerical duration fields include explicit units.",
      "requires_llm_evaluation": false,
      "llm_evaluation_reasoning": "üîß Static analysis can verify this rule using regex pattern matching against field names in specifications. Check for numerical duration fields using naming pattern analysis: fields should match `.*Seconds$`, `.*Hours$`, `.*Days$`, `.*Minutes$` patterns or similar unit suffixes.",
      "is_reviewed": false,
      "is_updated": false,
      "url": "https://developer.cisco.com/api-guidelines/semantic-naming-field-03/#duration-fields"
    },
    "status": "FAIL",
    "priority": "P1",
    "priority_reasoning": "MUST - Duration field naming with explicit units is a key convention for clarity.",
    "recommendation": {
      "location": "components.schemas.StageInfo.properties.elapsedTime (used in completedStages and currentStage arrays)",
      "reasoning": "The field 'elapsedTime' violates SEMANTIC.NAMING.FIELD.03-05 by not including explicit unit information in the field name. Per the rule, numerical duration fields MUST include the unit explicitly using the {qualifier}{Unit} pattern. The field is documented as 'Elapsed time in seconds' but the name 'elapsedTime' does not convey the unit. According to the rule examples, this should be named 'elapsedSeconds' to follow the {qualifier}{Unit} pattern and explicitly communicate the time unit to API consumers.",
      "is_breaking_change": true,
      "is_breaking_change_reasoning": "üí• Renaming 'elapsedTime' to 'elapsedSeconds' is a breaking change. Existing API clients have hardcoded field references (e.g., payload.elapsedTime in deserialization code, JSON path expressions in templates). When the field name changes, clients attempting to access 'elapsedTime' receive undefined values or null pointer exceptions, requiring code updates and redeployment.",
      "current_spec": "\"elapsedTime\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"Elapsedtime\",\n  \"description\": \"Elapsed time in seconds\"\n}",
      "recommended_spec": "\"elapsedSeconds\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"ElapsedSeconds\",\n  \"description\": \"Elapsed time in seconds\"\n}",
      "markdown": "## üü† P1 Duration Field Missing Explicit Unit\n\n### Overview\n| | |\n|---|---|\n| **Priority Reasoning** | MUST - Duration field naming with explicit units is a key convention for clarity. |\n| **Issue** | Duration field 'elapsedTime' lacks explicit unit specification in the field name |\n| **Rule** | SEMANTIC.NAMING.FIELD.03-05 - https://developer.cisco.com/api-guidelines/semantic-naming-field-03/#duration-fields |\n| **Breaking Change** | true |\n| **Location** | components.schemas.StageInfo.properties.elapsedTime |\n\n### Analysis\n\n#### Issue Reasoning\nThe StageInfo schema contains a field 'elapsedTime' that violates SEMANTIC.NAMING.FIELD.03-05. The rule explicitly requires: 'APIs using numerical values for durations must include the unit explicitly in the field name using the {qualifier}{Unit} pattern.' Examples provided include 'timeoutSeconds', 'retentionHours', 'maxSessionDurationMinutes'. The field 'elapsedTime' uses generic 'Time' as the unit indicator rather than the specific 'Seconds' unit. While the description states 'Elapsed time in seconds', the field name should communicate this directly per the rule. The correct naming would be 'elapsedSeconds'.\n\n#### Issue Impact\nAPI consumers reading the field name 'elapsedTime' cannot immediately determine the time unit without consulting documentation. This creates potential for misinterpretation (is it milliseconds? seconds? minutes?) and violates the principle of explicit API contracts. Developers might incorrectly assume the value represents milliseconds (a common assumption) and calculate incorrect durations, leading to bugs in client code.\n\n#### Breaking Change Reasoning\nüí• Renaming 'elapsedTime' to 'elapsedSeconds' is a breaking change. Existing API clients have JSON deserialization logic that references the field by name (e.g., `stage.elapsedTime`, `response['elapsedTime']`). When the field name changes, these references fail, resulting in undefined values or property access errors. Client code must be updated to reference the new field name, requiring version updates and client-side deployment.\n\n### Implementation\n\n#### Current Implementation\n```json\n\"elapsedTime\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"Elapsedtime\",\n  \"description\": \"Elapsed time in seconds\"\n}\n```\n\n#### Recommended Implementation\n```json\n\"elapsedSeconds\": {\n  \"anyOf\": [\n    {\"type\": \"integer\"},\n    {\"type\": \"null\"}\n  ],\n  \"title\": \"ElapsedSeconds\",\n  \"description\": \"Elapsed time in seconds\"\n}\n```"
    }
  }
]