[
  {
    "rule": {
      "rule_id": "SEMANTIC.NAMING.FIELD.08-01",
      "domain": "REST;GraphQL;gRPC;Devices",
      "priority": "P0",
      "priority_reasoning": "Explicit 'MUST be adopted' language indicates critical stop-ship requirement for standardized field names when corresponding data elements are present in APIs.",
      "category": "Common Fields - Standardization",
      "file_reference": "products/semantic/SEMANTIC.NAMING.FIELD.08.md",
      "summary": "APIs must use standardized field names (id, name, description, createdAt, updatedAt, and others from the common field names table) for common data concepts. This requirement applies when the API includes the corresponding data elements.",
      "original_content": "# Common Fields\n\nCommon data concepts use standardized field names (`id`, `name`, `description`, `createdAt`, `updatedAt`) across all APIs. Standard field names reduce developer cognitive load and improve integration predictability when working with frequently occurring data patterns.\n\n## Usage Requirements\n\nUse standardized field names for common data concepts to ensure consistent developer experience across all Cisco APIs. These field names MUST be adopted when the API includes the corresponding data elements.\n\n## Common Field Names\n\n| Field Name | Data Type | Description |\n|------------|-----------|-------------|\n| `attendees` | Array of objects | List of people attending an event |\n| `body` | String | Primary content of a message, document, or request |\n| `children` | Array of objects | Nested or subordinate items in a hierarchy |\n| `country` | String | Country name or ISO country code |\n| `createdAt` | DateTime | When the entity was created |\n| `createdBy` | String/Object | User or system that created the entity |\n| `displayName` | String | User-friendly name for presentation |\n| `event` | Object | Information about a specific event or occurrence |\n| `fullName` | String | Person's complete name including all parts |\n| `givenName` | String | Person's given/first name |\n| `jobTitle` | String | Person's role or job title |\n| `kind` | String | Type or category of the entity |\n| `id` | String/Integer | Primary identifier for the entity |\n| `location` | String/Object | Geographic or logical location |\n| `memberOf` | Array of objects | Groups or organizations the entity belongs to |\n| `message` | String | Text content of a message or notification |\n| `modifiedAt` | DateTime | When the entity was last updated |\n| `name` | String | Main name or title of the entity |\n| `owner` | String/Object | User or entity that owns the resource |\n| `people` | Array of objects | Collection of person entities |\n| `person` | Object | Single person entity |\n| `photo` | String/Object | Profile picture or image URL/data |\n| `postalCode` | String | Postal or ZIP code for addressing |\n| `preferredLanguage` | String | User's preferred language (BCP 47 language tag) |\n| `properties` | Object | Key-value pairs for extensible properties |\n| `tags` | Array of strings | Labels for categorization or filtering |",
      "has_examples": false,
      "confidence": 0.95,
      "confidence_reasoning": "Clear MUST requirement with comprehensive reference table. The requirement is explicit and actionable: use specified field names when corresponding data elements are present.",
      "classification": "InSpec",
      "classification_reasoning": "Field name standardization can be verified by analyzing the API specification to check whether common data concepts use standardized field names from the provided table.",
      "requires_llm_evaluation": false,
      "llm_evaluation_reasoning": "üîß Static analysis can verify this rule by pattern matching field names in API specifications against the standardized field names table and checking for presence when corresponding data elements exist.",
      "is_reviewed": false,
      "is_updated": false,
      "url": "https://developer.cisco.com/api-guidelines/semantic-naming-field-08/"
    },
    "status": "FAIL",
    "priority": "P0",
    "priority_reasoning": "MUST - Critical standardization requirement for API consistency",
    "recommendation": {
      "location": "responses.202.content.application/json.schema.properties (BundleResponse schema, L25-40)",
      "reasoning": "The BundleResponse schema uses non-standard field name 'fileName' instead of the standardized field name pattern. According to SEMANTIC.NAMING.FIELD.08-01, common data concepts should use standardized names. The field 'fileName' represents a file name, which should follow the standardized naming convention. Additionally, there are no lifecycle timestamp fields (createdAt, updatedAt) present in the response schema, which are recommended standard fields for tracking resource lifecycle. The spec declares a 'fileName' field but does not include standard identifier or timestamp fields expected in modern REST API responses.",
      "is_breaking_change": true,
      "is_breaking_change_reasoning": "üí• Renaming 'fileName' to a standardized field name would be a breaking change for existing API consumers who have built clients expecting the 'fileName' field name. However, adding missing standard fields like timestamps would be non-breaking.",
      "current_spec": "{\n  \"properties\": {\n    \"id\": {\n      \"type\": \"string\",\n      \"format\": \"uuid\",\n      \"title\": \"Id\",\n      \"description\": \"Unique bundle ID for tracking the bundle processing\"\n    },\n    \"fileName\": {\n      \"type\": \"string\",\n      \"title\": \"Filename\",\n      \"description\": \"Filename being processed\"\n    }\n  },\n  \"type\": \"object\",\n  \"required\": [\"id\", \"fileName\"],\n  \"title\": \"BundleResponse\"\n}",
      "recommended_spec": "{\n  \"properties\": {\n    \"id\": {\n      \"type\": \"string\",\n      \"format\": \"uuid\",\n      \"title\": \"Id\",\n      \"description\": \"Unique bundle ID for tracking the bundle processing\"\n    },\n    \"name\": {\n      \"type\": \"string\",\n      \"title\": \"Name\",\n      \"description\": \"Filename being processed\"\n    },\n    \"createdAt\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"title\": \"Created At\",\n      \"description\": \"Timestamp when the bundle was created\"\n    },\n    \"updatedAt\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"title\": \"Updated At\",\n      \"description\": \"Timestamp when the bundle was last updated\"\n    }\n  },\n  \"type\": \"object\",\n  \"required\": [\"id\", \"name\"],\n  \"title\": \"BundleResponse\"\n}",
      "markdown": "## üî¥ P0 - Standardized Field Names Not Adopted\n\n### Overview\n| | |\n|---|---|\n| **Priority Reasoning** | MUST - Critical standardization requirement for API consistency |\n| **Issue** | Response schema uses non-standardized field name 'fileName' instead of 'name'; missing standard lifecycle timestamp fields |\n| **Rule** | SEMANTIC.NAMING.FIELD.08-01 - https://developer.cisco.com/api-guidelines/semantic-naming-field-08/ |\n| **Breaking Change** | true |\n| **Location** | responses.202.content.application/json.schema.properties (BundleResponse schema) |\n\n### Analysis\n\n#### Issue Reasoning\nThe BundleResponse schema violates SEMANTIC.NAMING.FIELD.08-01 by using the non-standardized field name 'fileName' instead of adopting the common field name 'name' for representing file names. Additionally, the schema lacks recommended standard fields (createdAt, updatedAt) for entity lifecycle tracking. According to the rule, APIs must use standardized field names when corresponding data elements are present.\n\n#### Issue Impact\nNon-standardized field names create API inconsistency, increase developer cognitive load, and violate Cisco API quality standards. The absence of lifecycle timestamp fields limits audit trail capabilities and violates best practices for entity lifecycle tracking across Cisco APIs.\n\n#### Breaking Change Reasoning\nüí• Renaming 'fileName' to 'name' would be breaking for existing consumers. However, this is required by the P0 mandatory standard. The addition of optional fields (createdAt, updatedAt) would be non-breaking but should be included for consistency.\n\n### Implementation\n\n#### Current Implementation\n```json\n{\n  \"properties\": {\n    \"id\": {\n      \"type\": \"string\",\n      \"format\": \"uuid\",\n      \"title\": \"Id\",\n      \"description\": \"Unique bundle ID for tracking the bundle processing\"\n    },\n    \"fileName\": {\n      \"type\": \"string\",\n      \"title\": \"Filename\",\n      \"description\": \"Filename being processed\"\n    }\n  },\n  \"type\": \"object\",\n  \"required\": [\"id\", \"fileName\"],\n  \"title\": \"BundleResponse\"\n}\n```\n\n#### Recommended Implementation\n```json\n{\n  \"properties\": {\n    \"id\": {\n      \"type\": \"string\",\n      \"format\": \"uuid\",\n      \"title\": \"Id\",\n      \"description\": \"Unique bundle ID for tracking the bundle processing\"\n    },\n    \"name\": {\n      \"type\": \"string\",\n      \"title\": \"Name\",\n      \"description\": \"Filename being processed\"\n    },\n    \"createdAt\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"title\": \"Created At\",\n      \"description\": \"Timestamp when the bundle was created\"\n    },\n    \"updatedAt\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"title\": \"Updated At\",\n      \"description\": \"Timestamp when the bundle was last updated\"\n    }\n  },\n  \"type\": \"object\",\n  \"required\": [\"id\", \"name\"],\n  \"title\": \"BundleResponse\"\n}\n```"
    }
  },
  {
    "rule": {
      "rule_id": "SEMANTIC.NAMING.FIELD.01-08",
      "domain": "REST;GraphQL;gRPC;Devices",
      "priority": "P0",
      "priority_reasoning": "Uses explicit 'MUST' keyword. Technology-specific casing conventions are foundational requirements that ensure API specifications conform to language and framework standards.",
      "category": "Naming - Capitalization Conventions",
      "file_reference": "products/semantic/SEMANTIC.NAMING.FIELD.01.md",
      "summary": "Field names must follow established capitalization conventions for each API technology: lowerCamelCase for REST/JSON and GraphQL, underscore_separated_names for gRPC/Protocol Buffers.",
      "original_content": "## Capitalization Conventions\n\n### Technology-Specific Casing\n\nField names MUST follow the established capitalization conventions for each API technology:\n\n- **REST/JSON**: `lowerCamelCase` ([RFC 8259](https://tools.ietf.org/html/rfc8259))\n- **GraphQL**: `lowerCamelCase` ([GraphQL Spec](https://spec.graphql.org/October2021/#sec-Names))\n- **gRPC/Protocol Buffers**: `underscore_separated_names` ([Proto3 Style Guide](https://protobuf.dev/programming-guides/style/#message-and-field-names))",
      "has_examples": false,
      "confidence": 0.98,
      "confidence_reasoning": "Explicit MUST requirement with clear mapping of casing conventions to technologies, backed by authoritative external standards (RFC 8259, GraphQL Spec, Proto3 Guide).",
      "classification": "InSpec",
      "classification_reasoning": "Casing conventions can be directly verified by examining field names in API specifications and checking their casing against technology-specific requirements.",
      "requires_llm_evaluation": false,
      "llm_evaluation_reasoning": "üîß Can be implemented using static analysis with regex patterns to detect camelCase vs snake_case violations for each API technology type, validated against the specification format (OpenAPI, GraphQL schema, or Proto file).",
      "is_reviewed": false,
      "is_updated": false,
      "url": "https://developer.cisco.com/api-guidelines/semantic-naming-field-01/#technology-specific-casing"
    },
    "status": "FAIL",
    "priority": "P0",
    "priority_reasoning": "MUST - Foundational requirement for API specification consistency",
    "recommendation": {
      "location": "components.schemas.Body_import_upgrade_bundle.properties and components.schemas.BundleResponse.properties (L5-8, L22-40)",
      "reasoning": "The OpenAPI specification uses 'fileName' field name which violates lowerCamelCase convention for REST/JSON. Correct casing should be 'filename' (all lowercase) or 'fileName' if following strict camelCase. The current implementation 'fileName' is technically camelCase, but the issue is inconsistency with the base pattern. More critically, examining the schema: the field is documented as 'Filename' in title and 'fileName' in property name. The title uses capitalized 'F' while the field uses camelCase 'f'. For REST/JSON APIs (OpenAPI 3.1.0), lowerCamelCase requires the first letter to be lowercase. The specification shows 'fileName' which is correct camelCase. However, the schema object name 'Body_import_upgrade_bundle' uses snake_case naming, which violates lowerCamelCase requirement for REST JSON field and schema names.",
      "is_breaking_change": true,
      "is_breaking_change_reasoning": "üí• Renaming schema object 'Body_import_upgrade_bundle' to 'ImportUpgradeBundleBody' or similar camelCase format would be a breaking change if consumers reference this schema by name. However, the property names themselves ('fileName' is acceptable camelCase) are compliant. The primary violation is the schema object name using snake_case instead of PascalCase for schema names in OpenAPI.",
      "current_spec": "\"Body_import_upgrade_bundle\": {\n  \"properties\": {\n    \"file\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\",\n          \"format\": \"binary\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"File\"\n    },\n    \"filename\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Filename\"\n    }\n  },\n  \"type\": \"object\",\n  \"title\": \"Body_import_upgrade_bundle\"\n}",
      "recommended_spec": "\"ImportUpgradeBundleBody\": {\n  \"properties\": {\n    \"file\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\",\n          \"format\": \"binary\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"File\"\n    },\n    \"filename\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"title\": \"Filename\"\n    }\n  },\n  \"type\": \"object\",\n  \"title\": \"ImportUpgradeBundleBody\"\n}",
      "markdown": "## üî¥ P0 - Schema Object Name Violates Naming Conventions\n\n### Overview\n| | |\n|---|---|\n| **Priority Reasoning** | MUST - Foundational requirement for API specification consistency |\n| **Issue** | Schema object 'Body_import_upgrade_bundle' uses snake_case instead of PascalCase convention for OpenAPI schema names |\n| **Rule** | SEMANTIC.NAMING.FIELD.01-08 - https://developer.cisco.com/api-guidelines/semantic-naming-field-01/#technology-specific-casing |\n| **Breaking Change** | true |\n| **Location** | components.schemas.Body_import_upgrade_bundle |\n\n### Analysis\n\n#### Issue Reasoning\nThe schema object name 'Body_import_upgrade_bundle' violates lowerCamelCase/PascalCase conventions for REST/JSON OpenAPI specifications. OpenAPI schema names should use PascalCase (e.g., 'ImportUpgradeBundleBody') rather than snake_case. This inconsistency with naming conventions reduces API specification professionalism and creates developer confusion about naming patterns.\n\n#### Issue Impact\nNon-compliant schema naming creates inconsistency across the API specification and violates Cisco API style guide standards. Developers expect consistent casing patterns and may generate incorrect SDK code if schema names do not follow conventions.\n\n#### Breaking Change Reasoning\nüí• Renaming the schema object from 'Body_import_upgrade_bundle' to 'ImportUpgradeBundleBody' is technically a breaking change if external consumers directly reference this schema name. However, this is required by P0 standards.\n\n### Implementation\n\n#### Current Implementation\n```json\n\"Body_import_upgrade_bundle\": {\n  \"properties\": {\n    \"file\": { ... },\n    \"filename\": { ... }\n  },\n  \"type\": \"object\",\n  \"title\": \"Body_import_upgrade_bundle\"\n}\n```\n\n#### Recommended Implementation\n```json\n\"ImportUpgradeBundleBody\": {\n  \"properties\": {\n    \"file\": { ... },\n    \"filename\": { ... }\n  },\n  \"type\": \"object\",\n  \"title\": \"ImportUpgradeBundleBody\"\n}\n```"
    }
  },
  {
    "rule": {
      "rule_id": "SEMANTIC.NAMING.FIELD.03-07",
      "domain": "REST",
      "priority": "P0",
      "priority_reasoning": "The rule uses the mandatory keyword 'MUST' for timestamp fields in REST APIs. This is a critical structural requirement that must be enforced before API release.",
      "category": "Temporal Value Format - REST APIs",
      "file_reference": "products/semantic/SEMANTIC.NAMING.FIELD.03.md",
      "summary": "REST APIs must use RFC 3339 format (ISO 8601 profile) with the format YYYY-MM-DDTHH:MM:SSZ for timestamp fields. This ensures consistent, machine-parseable representation of date-time values across all REST API implementations.",
      "original_content": "### REST APIs (OpenAPI)\n\n**Date-only fields** MUST use ISO 8601 date format (`YYYY-MM-DD`):\n**Timestamp fields** MUST use RFC 3339 format (ISO 8601 profile) (`YYYY-MM-DDTHH:MM:SSZ`):\n**Time-of-day fields** MUST use ISO 8601 time format (`HH:MM:SS` or `HH:MM:SS.sss`):\n**Duration fields** SHOULD use ISO 8601 duration format (e.g., `PT4H30M`) for complex durations or numerical values with explicit units for simple durations.",
      "has_examples": true,
      "confidence": 0.95,
      "confidence_reasoning": "The rule is explicitly stated with mandatory keyword 'MUST' and includes specific format specification (RFC 3339 / YYYY-MM-DDTHH:MM:SSZ). The requirement is unambiguous and directly verifiable.",
      "classification": "InSpec",
      "classification_reasoning": "This rule can be verified by analyzing REST API specifications (OpenAPI documents) to check if timestamp field values conform to RFC 3339 format.",
      "requires_llm_evaluation": false,
      "llm_evaluation_reasoning": "üîß Static analysis can verify this rule using regex pattern matching and RFC 3339 format validation. Check timestamp values using regex pattern `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$` to verify RFC 3339 conformance.",
      "is_reviewed": false,
      "is_updated": false,
      "url": "https://developer.cisco.com/api-guidelines/semantic-naming-field-03/#rest-apis-openapi"
    },
    "status": "PARTIAL",
    "priority": "P0",
    "priority_reasoning": "MUST - Critical structural requirement for date-time format consistency",
    "recommendation": {
      "location": "components.schemas.BundleResponse (proposed addition of timestamp fields)",
      "reasoning": "While the current BundleResponse schema does not include explicit timestamp fields like createdAt or updatedAt, if such fields were to be added in the future, they must conform to RFC 3339 format. The specification currently lacks any timestamp fields entirely, which means there is no violation of the format requirement, but also means the schema is incomplete per SEMANTIC.NAMING.FIELD.03-16 (Entity Lifecycle Timestamps). The recommendation addresses both rules: (1) add createdAt and updatedAt fields per P1 rule 03-16, and (2) ensure these use RFC 3339 format per P0 rule 03-07.",
      "is_breaking_change": false,
      "is_breaking_change_reasoning": "üõ°Ô∏è Adding new optional timestamp fields to the response is non-breaking for existing API consumers. The addition of createdAt and updatedAt as optional fields only expands the response structure without affecting existing field behavior.",
      "current_spec": "\"BundleResponse\": {\n  \"properties\": {\n    \"id\": {\n      \"type\": \"string\",\n      \"format\": \"uuid\",\n      \"title\": \"Id\",\n      \"description\": \"Unique bundle ID for tracking the bundle processing\"\n    },\n    \"fileName\": {\n      \"type\": \"string\",\n      \"title\": \"Filename\",\n      \"description\": \"Filename being processed\"\n    }\n  },\n  \"type\": \"object\",\n  \"required\": [\"id\", \"fileName\"],\n  \"title\": \"BundleResponse\"\n}",
      "recommended_spec": "\"BundleResponse\": {\n  \"properties\": {\n    \"id\": {\n      \"type\": \"string\",\n      \"format\": \"uuid\",\n      \"title\": \"Id\",\n      \"description\": \"Unique bundle ID for tracking the bundle processing\"\n    },\n    \"name\": {\n      \"type\": \"string\",\n      \"title\": \"Name\",\n      \"description\": \"Filename being processed\"\n    },\n    \"createdAt\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"title\": \"Created At\",\n      \"description\": \"RFC 3339 timestamp when the bundle was created, format: YYYY-MM-DDTHH:MM:SSZ\"\n    },\n    \"updatedAt\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"title\": \"Updated At\",\n      \"description\": \"RFC 3339 timestamp when the bundle was last updated, format: YYYY-MM-DDTHH:MM:SSZ\"\n    }\n  },\n  \"type\": \"object\",\n  \"required\": [\"id\", \"name\"],\n  \"title\": \"BundleResponse\"\n}",
      "markdown": "## üî¥ P0 - Timestamp Fields Missing / RFC 3339 Format Not Declared\n\n### Overview\n| | |\n|---|---|\n| **Priority Reasoning** | MUST - Critical structural requirement for date-time format consistency |\n| **Issue** | Response schema lacks timestamp fields (createdAt, updatedAt); if added, must explicitly declare RFC 3339 format |\n| **Rule** | SEMANTIC.NAMING.FIELD.03-07 - https://developer.cisco.com/api-guidelines/semantic-naming-field-03/#rest-apis-openapi |\n| **Breaking Change** | false |\n| **Location** | components.schemas.BundleResponse |\n\n### Analysis\n\n#### Issue Reasoning\nThe BundleResponse schema currently lacks lifecycle timestamp fields. While this is not a direct violation of SEMANTIC.NAMING.FIELD.03-07 (which governs format when timestamps are present), it represents incomplete adherence to Cisco API standards. When timestamp fields are added, they must conform to RFC 3339 format with explicit 'date-time' format declaration in OpenAPI schema.\n\n#### Issue Impact\nMissing timestamp fields limit audit capabilities and violate entity lifecycle tracking best practices. When timestamps are eventually added without proper format specification, there is risk of inconsistent date-time representation across the API ecosystem.\n\n#### Breaking Change Reasoning\nüõ°Ô∏è Adding new timestamp fields as optional response properties is non-breaking for existing consumers. The expansion of response structure does not affect existing field contracts.\n\n### Implementation\n\n#### Current Implementation\n```json\n\"BundleResponse\": {\n  \"properties\": {\n    \"id\": { \"type\": \"string\", \"format\": \"uuid\", ... },\n    \"fileName\": { \"type\": \"string\", ... }\n  },\n  \"type\": \"object\",\n  \"required\": [\"id\", \"fileName\"],\n  \"title\": \"BundleResponse\"\n}\n```\n\n#### Recommended Implementation\n```json\n\"BundleResponse\": {\n  \"properties\": {\n    \"id\": { \"type\": \"string\", \"format\": \"uuid\", ... },\n    \"name\": { \"type\": \"string\", ... },\n    \"createdAt\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"description\": \"RFC 3339 timestamp when the bundle was created, format: YYYY-MM-DDTHH:MM:SSZ\"\n    },\n    \"updatedAt\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\",\n      \"description\": \"RFC 3339 timestamp when the bundle was last updated, format: YYYY-MM-DDTHH:MM:SSZ\"\n    }\n  },\n  \"type\": \"object\",\n  \"required\": [\"id\", \"name\"],\n  \"title\": \"BundleResponse\"\n}\n```"
    }
  },
  {
    "rule": {
      "rule_id": "API.REST.STYLE.27",
      "domain": "REST",
      "priority": "P0",
      "priority_reasoning": "The rule uses 'should' and 'recommended' language with a comprehensive reference table showing appropriate status codes per HTTP method. HTTP status code selection is fundamental to REST API design and directly impacts client error handling, making it a key P0 requirement for API quality.",
      "category": "HTTP Status Codes",
      "file_reference": "rest/style.md",
      "summary": "APIs must respond with standardized HTTP status codes from the 2xx, 4xx, and 5xx ranges, selecting the most specific code that accurately represents the outcome of the request. The 2xx range indicates successful execution, 4xx indicates client-side problems, and 5xx indicates server errors. APIs must not invent new status codes and should only use standardized codes consistent with their documented semantics.",
      "original_content": "> <big><strong>[`API.REST.STYLE.27`](./recommendations.md#API.REST.STYLE.27)</strong></big>: My API responds with recommended HTTP status codes in the 2xx/4xx/5xx ranges.\n> <!-- recostop API.REST.STYLE.27 -->\n\nRESTful APIs use HTTP status codes to specify the outcomes of HTTP method execution. The HTTP protocol specifies the outcome of a request execution using an integer and a message. The number is known as the _status code_ and the message as the _reason phrase_. The reason phrase is a human readable message used to clarify the outcome of the response. \n\nThe HTTP protocol categorizes status codes in ranges:\n\n* HTTP Status Codes [RFC 9110](https://datatracker.ietf.org/doc/html/rfc9110#name-status-codes)\n* Additional HTTP Status Codes [RFC 6585](https://datatracker.ietf.org/doc/html/rfc6585)\n\nWhen responding to API requests, the following status code ranges should be used:\n\n| Range | Meaning |\n| --- | --- |\n| `2xx` |Successful execution. It is possible for a method execution to succeed in different ways, this status code specifies which way it succeeded |\n| `4xx` |Problems with the request, the data in the request, invalid authentication or authorization, etc. In most cases the client can modify/correct the request and resubmit |\n| `5xx` | Server error: The server was not able to execute the request due to site outage, software defect, or some other unexpected. 5xx range status codes should not be utilized for validation or logical error handling |\n\nAddition guidelines for HTTP status codes usage:\n\n* Don't invent new HTTP status codes; only use standardized HTTP status codes, consistent with their intended semantics\n* Use the most specific HTTP status code for your processing status or error situation\n* If using HTTP status codes that are less commonly used, provide extensive guidance in your API documentation\n* Check this handy guide providing hints and decision flow-charts around choosing the best status code for particular situations: [Choosing an HTTP Status Code](https://www.codetinkerer.com/2015/12/04/choosing-an-http-status-code.html)\n\nREST APIs should generally use the status codes list below:\n\n| Status Code | Description                  |\n|-------------|------------------------------|\n| `200 OK` | Generic successful execution |\n| `201 Created` | Used as a response to `POST` method execution to indicate successful creation of a resource.\n| `202 Accepted` | Used for asynchronous method execution to specify the server has accepted the request and will execute it at a later time |\n| `204 No Content` | The server has successfully executed the method, but there is no entity body to return |\n| `400 Bad Request` | The request could not be understood by the server. Use this status code to specify:<br/> <ul><li>The data as part of the payload cannot be converted to the underlying data type</li><li>The data is not in the expected data format</li><li>A required field is not available.</li><li>Simple data validation type error</li></ul>|\n| `401 Unauthorized` | The request requires authentication and none was provided. Note the difference between this and `403 Forbidden` |\n| `403 Forbidden` | The client is not authorized to access the resource, although it may have valid credentials. APIs could use this code in case of business level authorization failure. For example, account holder does not have enough funds |\n| `404 Not Found` | The server has not found anything matching the request URI. This either means that the URI is incorrect or the resource is not available. For example, it may be that no data exists in the database at that key |\n| `405 Method Not Allowed` | The server has not implemented the requested HTTP method. This is typically default behavior for API frameworks |\n| `406 Not Acceptable` | The server must return this status code when it cannot return the payload of the response using the media type requested by the client. For example, if the client sends an `Accept: application/xml` header, and the API can only generate `application/json`, the server must return `406` |\n| `409 Conflict` | Request cannot be completed due to conflict, e.g. when two clients try to create the same resource or if there are concurrent, conflicting updates |\n| `410 Gone` | Resource does not exist any longer, e.g. when accessing a resource that has intentionally been deleted |\n| `415 Unsupported Media Type` | The server must return this status code when the media type of the request's payload cannot be processed. For example, if the client sends a `Content-Type: application/xml` header, but the API can only accept `application/json`, the server must return `415` |\n| `422 Unprocessable Entity` | The requested action cannot be performed and may require interaction with APIs or processes outside of the current request. This is distinct from a 500 response in that there are no systemic problems limiting the API from performing the request |\n| `429 Too Many Requests` | The server must return this status code if the rate limit for the user, the application, or the token has exceeded a predefined value |\n| `500 Internal Server Error` | This is either a system or application error, and generally indicates that although the client appeared to provide a correct request, something unexpected has gone wrong on the server. A `500` response indicates a server-side software defect or site outage. `500` should not indicate client request validation errors |\n| `501 Not Implemented` | Not Implemented - server cannot fulfill the request (usually implies future availability, e.g. new feature) |\n| `503 Service Unavailable` | The server is unable to handle the request for an operation due to temporary maintenance |\n\n### Mapping HTTP Methods with Status Codes\n\nFor each HTTP method, your API operations should use only status codes marked as \"X\"  in this table: \n\n_Note that status codes marked with a bold **`X`** are rarely used_\n\n| Status Code               | `GET`   | `POST`  | `PUT`   | `PATCH` | `DELETE` |\n|---------------------------|---------|---------|---------|---------|----------|\n| 200 OK                    | X       | X       | X       | X       | X        |\n| 201 Created               |         | X       |         |         |          |\n| 202 Accepted              |         | **`X`** | **`X`** |         |          |\n| 204 No Content            |         |         | X       | X       | X        |\n| 400 Bad Request           | X       | X       | X       | X       | X        |\n| 404 Not Found             | X       | **`X`** | X       | X       | X        |\n| 422 Unprocessable Entity  | **`X`** | **`X`** | **`X`** | **`X`** | **`X`**  |\n| 500 Internal Server Error | X       | X       | X       | X       | X        |",
      "has_examples": true,
      "confidence": 0.92,
      "confidence_reasoning": "The rule is clearly defined with explicit guidance on status code ranges, a comprehensive reference table with specific codes and their use cases, and a mapping table showing appropriate codes per HTTP method. The language uses 'should' and 'recommended' consistently. Minor ambiguity exists around implementation of less-common status codes, which relies on documentation quality.",
      "classification": "InSpec",
      "classification_reasoning": "This rule is verifiable through specification analysis. API responses can be examined against the OpenAPI specification to confirm that status codes used fall within the 2xx/4xx/5xx ranges and map correctly to HTTP methods as defined in the specification document.",
      "requires_llm_evaluation": false,
      "llm_evaluation_reasoning": "üîß This rule can be enforced through static analysis of the API specification. Parsers can extract all status codes defined in OpenAPI responses and verify they are (1) standardized HTTP codes from RFC 9110/6585, (2) within the 2xx/4xx/5xx ranges, and (3) aligned with the provided HTTP method-to-status code mapping table.",
      "is_reviewed": false,
      "is_updated": false,
      "url": "https://developer.cisco.com/api-guidelines/rest-style/#returning-http-status-codes"
    },
    "status": "PARTIAL",
    "priority": "P0",
    "priority_reasoning": "MUST - HTTP status code selection is fundamental to REST API design",
    "recommendation": {
      "location": "paths./cxue-platform-mgr/api/v1/upgrades/import.post.responses (L16-52)",
      "reasoning": "The POST /upgrades/import endpoint declares responses with status codes 202 and 422, which are valid HTTP status codes. However, the specification lacks responses for other standardized error conditions that should be handled: (1) 400 Bad Request - for invalid request parameters or malformed multipart data; (2) 401 Unauthorized - if authentication is required but missing; (3) 403 Forbidden - if the user lacks permission; (4) 500 Internal Server Error - for server-side failures. The operation specifies 'processing: Uses pre-configured SCP servers and downloads asynchronously in background', which implies potential failure scenarios. Additionally, the 422 response is appropriate for validation errors on form data, but the spec should also include 400 for other client errors. The current implementation is incomplete in error response coverage.",
      "is_breaking_change": false,
      "is_breaking_change_reasoning": "üõ°Ô∏è Adding additional error response status codes (400, 401, 403, 500) to the specification is non-breaking for existing consumers. Adding new possible responses expands the contract but does not change existing 202/422 behavior. Clients that only handle 202 will continue to work; those that implement robust error handling can now properly handle additional error conditions.",
      "current_spec": "\"responses\": {\n  \"202\": {\n    \"description\": \"Successful Response\",\n    \"content\": {\n      \"application/json\": {\n        \"schema\": { ... }\n      }\n    }\n  },\n  \"422\": {\n    \"description\": \"Validation Error\",\n    \"content\": {\n      \"application/json\": {\n        \"schema\": { ... }\n      }\n    }\n  }\n}",
      "recommended_spec": "\"responses\": {\n  \"202\": {\n    \"description\": \"Successful Response - Bundle import initiated\",\n    \"content\": {\n      \"application/json\": {\n        \"schema\": { ... }\n      }\n    }\n  },\n  \"400\": {\n    \"description\": \"Bad Request - Malformed request or invalid parameters\",\n    \"content\": {\n      \"application/json\": {\n        \"schema\": {\n          \"properties\": {\n            \"detail\": { \"type\": \"string\" }\n          }\n        }\n      }\n    }\n  },\n  \"401\": {\n    \"description\": \"Unauthorized - Authentication required\",\n    \"content\": {\n      \"application/json\": {\n        \"schema\": {\n          \"properties\": {\n            \"detail\": { \"type\": \"string\" }\n          }\n        }\n      }\n    }\n  },\n  \"403\": {\n    \"description\": \"Forbidden - Insufficient permissions\",\n    \"content\": {\n      \"application/json\": {\n        \"schema\": {\n          \"properties\": {\n            \"detail\": { \"type\": \"string\" }\n          }\n        }\n      }\n    }\n  },\n  \"422\": {\n    \"description\": \"Validation Error - Invalid form data\",\n    \"content\": {\n      \"application/json\": {\n        \"schema\": { ... }\n      }\n    }\n  },\n  \"500\": {\n    \"description\": \"Internal Server Error - Server-side processing failure\",\n    \"content\": {\n      \"application/json\": {\n        \"schema\": {\n          \"properties\": {\n            \"detail\": { \"type\": \"string\" }\n          }\n        }\n      }\n    }\n  }\n}",
      "markdown": "## üî¥ P0 - Incomplete HTTP Status Code Responses\n\n### Overview\n| | |\n|---|---|\n| **Priority Reasoning** | MUST - HTTP status code selection is fundamental to REST API design |\n| **Issue** | POST endpoint declares only 202 and 422 responses; missing common error responses (400, 401, 403, 500) |\n| **Rule** | API.REST.STYLE.27 - https://developer.cisco.com/api-guidelines/rest-style/#returning-http-status-codes |\n| **Breaking Change** | false |\n| **Location** | paths./cxue-platform-mgr/api/v1/upgrades/import.post.responses |\n\n### Analysis\n\n#### Issue Reasoning\nThe specification declares status codes 202 Accepted (for successful asynchronous processing) and 422 Unprocessable Entity (for validation errors). However, per API.REST.STYLE.27, REST APIs must respond with standardized HTTP status codes that accurately represent all possible outcomes. The operation description mentions 'pre-configured SCP servers' and asynchronous background processing, implying multiple failure scenarios that should return appropriate error codes: 400 for malformed requests, 401 for authentication failures, 403 for authorization failures, and 500 for server errors.\n\n#### Issue Impact\nClients cannot properly handle all failure scenarios if error responses are under-specified. This violates REST API design principles and creates risk that clients will timeout or enter error states waiting for unexpected responses. Proper error response coverage enables robust client implementations and better error handling.\n\n#### Breaking Change Reasoning\nüõ°Ô∏è Adding new error response status codes is non-breaking for existing consumers. Clients built to handle 202 success will continue to work; the additional error codes provide enhanced error handling capabilities without changing existing successful response semantics.\n\n### Implementation\n\n#### Current Implementation\n```json\n\"responses\": {\n  \"202\": { \"description\": \"Successful Response\", ... },\n  \"422\": { \"description\": \"Validation Error\", ... }\n}\n```\n\n#### Recommended Implementation\n```json\n\"responses\": {\n  \"202\": { \"description\": \"Successful Response - Bundle import initiated\" },\n  \"400\": { \"description\": \"Bad Request - Malformed request or invalid parameters\" },\n  \"401\": { \"description\": \"Unauthorized - Authentication required\" },\n  \"403\": { \"description\": \"Forbidden - Insufficient permissions\" },\n  \"422\": { \"description\": \"Validation Error - Invalid form data\" },\n  \"500\": { \"description\": \"Internal Server Error - Server-side processing failure\" }\n}\n```"
    }
  }
]